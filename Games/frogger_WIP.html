<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Turtle Hopper</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        :root {
            --color-bg-dark: #121212;
            --color-ui: #FFFB00;
            --color-turtle: #34D399; /* Emerald Green */
            --color-road: #4B5563;   /* Gray/Black */
            --color-river: #3B82F6;  /* Blue River */
            --color-safe-zone: #10B981; /* Green safe zone */
            --color-log: #92400E;    /* Brown log */
            --color-car: #EF4444;    /* Red Car */
            --color-truck: #FBBF24;  /* Amber Truck */
            --grid-size: 40px;
        }

        body {
            background-color: var(--color-bg-dark);
            color: var(--color-ui);
            font-family: 'VT323', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            padding: 10px;
            margin: 0;
            min-height: 100vh;
            user-select: none;
        }

        #game-container {
            width: 100%;
            max-width: 420px;
            margin: 1rem auto;
            border: 4px solid var(--color-ui);
            box-shadow: 0 0 20px rgba(255, 251, 0, 0.5);
            background-color: var(--color-bg-dark);
            display: flex;
            flex-direction: column;
            position: relative;
        }

        canvas {
            background-color: #000;
            display: block;
            touch-action: none; /* Crucial for better mobile interaction */
        }

        /* UI and HUD */
        #hud {
            padding: 10px;
            background-color: #222;
            border-top: 2px solid var(--color-ui);
            display: flex;
            justify-content: space-between;
            align-items: center; /* Center items vertically */
            font-size: 1.5rem;
        }
        
        #hud-controls {
            display: flex;
            gap: 10px;
        }

        .hud-button {
            background-color: var(--color-road);
            color: var(--color-ui);
            padding: 5px 10px;
            border: 1px solid var(--color-ui);
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.2s;
        }

        .hud-button:hover {
            background-color: #555;
        }


        #controls-info {
            padding: 10px 0;
            font-size: 1rem;
            text-align: center;
        }

        .message-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
            text-align: center;
        }

        .message-content {
            padding: 2rem;
            border: 3px solid var(--color-turtle);
            background-color: #111;
            box-shadow: 0 0 30px rgba(52, 211, 153, 0.7);
            border-radius: 8px;
            max-width: 90%;
        }

        .action-button {
            background-color: var(--color-turtle);
            color: var(--color-bg-dark);
            padding: 10px 20px;
            border-radius: 4px;
            font-weight: 700;
            font-size: 1.2rem;
            cursor: pointer;
            margin-top: 15px;
            transition: opacity 0.2s;
        }
        .action-button:hover { opacity: 0.8; }
        
        /* Mobile Controls */
        #mobile-controls {
            display: grid;
            grid-template-areas:
                ". up ."
                "left . right"
                ". down .";
            width: 200px;
            height: 200px;
            margin-top: 20px;
        }

        .mobile-btn {
            background-color: var(--color-ui);
            color: var(--color-bg-dark);
            padding: 10px;
            border-radius: 8px;
            font-size: 1.5rem;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 0 5px var(--color-ui);
            cursor: pointer;
        }

        #up-btn { grid-area: up; }
        #down-btn { grid-area: down; }
        #left-btn { grid-area: left; }
        #right-btn { grid-area: right; }
        
        @media (min-width: 801px) {
            #mobile-controls {
                display: none;
            }
        }
    </style>
</head>
<body>

    <div id="game-container">
        

<canvas id="gameCanvas"></canvas>

        

<div id="hud">
            <div id="score">SCORE: 0</div>
            <div id="timer">TIMER: 15.00s</div>
            <div id="lives">LIVES: 3</div>
            <div id="hud-controls">
                <button id="reset-button" class="hud-button">RESET</button>
            </div>
        </div>

        

<div id="controls-info">
            Use **WASD** or **Arrow Keys** to move.
        </div>
        
        

<div id="message-overlay" class="message-overlay">
            <div class="message-content">
                <h2 id="message-title" class="text-3xl font-bold mb-4"></h2>
                <p id="message-text" class="mb-4 text-xl"></p>
                <button class="action-button" id="restart-button">START HOPPING</button>
            </div>
        </div>
    </div>

    

<div id="mobile-controls">
        <button class="mobile-btn" id="up-btn">↑</button>
        <button class="mobile-btn" id="left-btn">←</button>
        <button class="mobile-btn" id="right-btn">→</button>
        <button class="mobile-btn" id="down-btn">↓</button>
    </div>

    <script>
        // --- Configuration Constants ---
        const GRID_SIZE = 40;
        const GRID_COLS = 10;
        const GRID_ROWS = 10;
        const CANVAS_WIDTH = GRID_COLS * GRID_SIZE;
        const CANVAS_HEIGHT = GRID_ROWS * GRID_SIZE;
        
        // --- DOM Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const livesDisplay = document.getElementById('lives');
        const timerDisplay = document.getElementById('timer'); // NEW: Timer display element
        const messageOverlay = document.getElementById('message-overlay');
        const messageTitle = document.getElementById('message-title');
        const messageText = document.getElementById('message-text');
        const restartButton = document.getElementById('restart-button');
        const resetButton = document.getElementById('reset-button');

        // --- Game State ---
        let gameState = {
            score: 0,
            lives: 3,
            turtle: null,
            lanes: [],
            isPaused: true,
            level: 1,
            lastUpdateTime: 0,
            deltaTime: 0,
            animationFrameId: null,
            timeLimit: 15, // Max time in seconds
            currentTime: 15, // Current remaining time
        };

        // Helper function to calculate the time limit based on the current level
        function getLaneTimeLimit() {
            if (gameState.level <= 10) {
                // Starts at 15s (Level 1) and decreases by 1s up to Level 10 (6s)
                return 15 - (gameState.level - 1);
            } else {
                // Fixed at 5 seconds for Level 11 and above
                return 5;
            }
        }


        // --- Player (Turtle) Class ---
        class Turtle {
            constructor() {
                this.reset();
            }

            reset() {
                // Initial position: center of the start lane (row 9)
                this.x = (GRID_COLS / 2 - 0.5) * GRID_SIZE;
                this.y = (GRID_ROWS - 1) * GRID_SIZE;
                this.isCarried = false; // Is the turtle currently on a platform?
                this.carriedBy = null; // Reference to the entity carrying it
                this.targetX = this.x;
                this.targetY = this.y;
                this.movementSpeed = 1.0; // Instant hop for classic Frogger feel
            }

            draw() {
                // Instantly update position to target for snappy movement
                this.x = this.targetX;
                this.y = this.targetY;

                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--color-turtle').trim();
                
                // Draw a stylized turtle (a rounded square)
                const padding = 5;
                const size = GRID_SIZE - 2 * padding;
                ctx.fillRect(this.x + padding, this.y + padding, size, size);
                
                // Eyes for direction (simple indication)
                ctx.fillStyle = '#FFF';
                ctx.fillRect(this.x + GRID_SIZE / 4, this.y + padding, 5, 5);
                ctx.fillRect(this.x + GRID_SIZE * 3 / 4 - 5, this.y + padding, 5, 5);
            }

            move(dx, dy) {
                if (gameState.isPaused) return;
                
                // Snap to grid before calculating the new target. 
                // This ensures the current X/Y are always a clean grid coordinate.
                this.snapToGrid(); 

                // Calculate new target position, clamped to canvas boundaries
                const newTargetX = Math.min(CANVAS_WIDTH - GRID_SIZE, Math.max(0, this.targetX + dx));
                const newTargetY = Math.min(CANVAS_HEIGHT - GRID_SIZE, Math.max(0, this.targetY + dy));
                
                // Check if an actual move happened (prevent scoring for no movement)
                const movedVertically = newTargetY !== this.targetY;

                this.targetX = newTargetX;
                this.targetY = newTargetY;
                this.isCarried = false;
                this.carriedBy = null;

                // Update score if moving forward (up)
                if (movedVertically && dy < 0) {
                    // Only update score if moving to a new, higher row
                    const newRow = newTargetY / GRID_SIZE;
                    const oldRow = Math.floor(this.y / GRID_SIZE); // Use current Y
                    if (newRow < oldRow) {
                        gameState.score += 10;
                    }
                }
            }

            snapToGrid() {
                 // Force X and Y to be on the grid
                 this.x = Math.round(this.x / GRID_SIZE) * GRID_SIZE;
                 this.y = Math.round(this.y / GRID_SIZE) * GRID_SIZE;
                 this.targetX = this.x;
                 this.targetY = this.y;
            }
        }

        // --- Lane Classes ---

        class Entity {
            constructor(x, y, width, speed, color) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = GRID_SIZE;
                this.speed = speed;
                this.color = color;
            }

            update(deltaTime) {
                // Removed speed multiplier for constant speed based on user request
                this.x += this.speed * deltaTime / 1000; 

                // Wrap around horizontally
                if (this.speed > 0 && this.x > CANVAS_WIDTH) {
                    this.x = -this.width;
                } else if (this.speed < 0 && this.x < -this.width) {
                    this.x = CANVAS_WIDTH;
                }
            }

            draw(type) {
                ctx.fillStyle = this.color;
                
                if (type === 'platform') {
                    // Logs: simple rectangle
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                } else if (type === 'car') {
                    // Cars: rounded rectangles
                    const radius = 5;
                    ctx.beginPath();
                    ctx.moveTo(this.x + radius, this.y);
                    ctx.lineTo(this.x + this.width - radius, this.y);
                    ctx.quadraticCurveTo(this.x + this.width, this.y, this.x + this.width, this.y + radius);
                    ctx.lineTo(this.x + this.width, this.y + this.height - radius);
                    ctx.quadraticCurveTo(this.x + this.width, this.y + this.height, this.x + this.width - radius, this.y + this.height);
                    ctx.lineTo(this.x + radius, this.y + this.height);
                    ctx.quadraticCurveTo(this.x, this.y + this.height, this.x, this.y + this.height - radius);
                    ctx.lineTo(this.x, this.y + radius);
                    ctx.quadraticCurveTo(this.x, this.y, this.x + radius, this.y);
                    ctx.closePath();
                    ctx.fill();
                }
            }

            // Checks if the player is colliding with this entity
            isColliding(player) {
                const p = player;
                const e = this;
                const pPadding = 5;
                const pX = p.x + pPadding;
                const pY = p.y + pPadding;
                const pW = GRID_SIZE - 2 * pPadding;
                const pH = GRID_SIZE - 2 * pPadding;

                return pX < e.x + e.width &&
                       pX + pW > e.x &&
                       pY < e.y + e.height &&
                       pY + pH > e.y;
            }
        }

        class Lane {
            constructor(r, type, speed, density, entityWidth) {
                this.r = r;
                this.y = r * GRID_SIZE;
                this.type = type; // 'safe', 'road', or 'river'
                this.speed = speed;
                this.density = density;
                this.entityWidth = entityWidth;
                this.entities = [];
                this.initEntities();
            }

            initEntities() {
                this.entities = []; // Clear existing entities
                if (this.density === 0) return; // No entities for safe zones

                // --- NEW DENSITY LOGIC START ---
                let spacingFactor = 1.0;
                if (this.type === 'road') {
                    // Drop half the cars (double the effective space)
                    spacingFactor = 2.0; 
                } else if (this.type === 'river') {
                    // Drop 1/3 of the logs (1.5x the effective space)
                    spacingFactor = 1.5; 
                }

                let currentX = 0;
                let maxIterations = 30; // Safety break
                let i = 0;

                // Loop until we've generated enough entities to span at least twice the canvas width, ensuring a good wrap
                while (currentX < CANVAS_WIDTH * 2 && i < maxIterations) {
                    const width = this.entityWidth * GRID_SIZE;
                    
                    // Determine entity color based on type and index
                    const color = this.type === 'road' ? 
                                  (i % 2 === 0 ? getComputedStyle(document.documentElement).getPropertyValue('--color-car').trim() : getComputedStyle(document.documentElement).getPropertyValue('--color-truck').trim()) : 
                                  getComputedStyle(document.documentElement).getPropertyValue('--color-log').trim();
                    
                    const entity = new Entity(currentX, this.y, width, this.speed, color);
                    this.entities.push(entity);
                    
                    // Apply spacing factor to the minimum gap (Original minGap was GRID_SIZE * 1.5)
                    const minGap = GRID_SIZE * 1.5 * spacingFactor;
                    const randomGap = Math.random() * GRID_SIZE * 0.5;
                    
                    currentX += width + minGap + randomGap;
                    i++;
                }
                // --- NEW DENSITY LOGIC END ---

                this.entities.sort((a, b) => a.x - b.x); 
            }

            update(deltaTime) {
                this.entities.forEach(entity => entity.update(deltaTime));
            }

            draw() {
                // Draw background color for non-safe lanes
                ctx.fillStyle = this.type === 'river' ? getComputedStyle(document.documentElement).getPropertyValue('--color-river').trim() : 
                                (this.type === 'road' ? getComputedStyle(document.documentElement).getPropertyValue('--color-road').trim() : 
                                getComputedStyle(document.documentElement).getPropertyValue('--color-safe-zone').trim());
                
                // Draw a slightly darker shade for the start/home lanes
                if (this.r === 0 || this.r === GRID_ROWS - 1) {
                    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--color-safe-zone').trim();
                }

                ctx.fillRect(0, this.y, CANVAS_WIDTH, GRID_SIZE);

                // Draw entities
                this.entities.forEach(entity => entity.draw(this.type === 'river' ? 'platform' : 'car'));
            }
        }

        // --- Core Game Functions ---
        
        function initGame() {
            // Setup Canvas size
            canvas.width = CANVAS_WIDTH;
            canvas.height = CANVAS_HEIGHT;
            
            // Reset core state
            gameState.score = 0;
            gameState.lives = 3;
            gameState.level = 1;
            gameState.isPaused = false;

            // NEW: Setup Time Limit
            gameState.timeLimit = getLaneTimeLimit();
            gameState.currentTime = gameState.timeLimit;
            
            // Create the player
            gameState.turtle = new Turtle();

            // Setup Lanes (0 is Home, 9 is Start)
            gameState.lanes = [];
            
            // Row 0: Home/Safe Zone
            gameState.lanes.push(new Lane(0, 'safe', 0, 0, 0)); 
            
            // Rows 1-4: River (Moving Platforms)
            gameState.lanes.push(new Lane(1, 'river', -40, 0.35, 3)); 
            gameState.lanes.push(new Lane(2, 'river', 60, 0.3, 2));  
            gameState.lanes.push(new Lane(3, 'river', -50, 0.4, 1.5));
            gameState.lanes.push(new Lane(4, 'river', 70, 0.35, 1));  
            
            // Row 5: Median/Safe Zone
            gameState.lanes.push(new Lane(5, 'safe', 0, 0, 0));
            
            // Rows 6-8: Road (Moving Cars/Hazards)
            gameState.lanes.push(new Lane(6, 'road', -80, 0.4, 1.5)); 
            gameState.lanes.push(new Lane(7, 'road', 100, 0.3, 1));  
            gameState.lanes.push(new Lane(8, 'road', -60, 0.45, 2));  
            
            // Row 9: Start/Safe Zone
            gameState.lanes.push(new Lane(9, 'safe', 0, 0, 0));

            updateHUD();
            messageOverlay.style.display = 'none';

            // Start the game loop if not already running
            if (!gameState.animationFrameId) {
                gameState.animationFrameId = requestAnimationFrame(animate);
            }
        }

        function updateHUD() {
            scoreDisplay.textContent = `SCORE: ${gameState.score}`;
            livesDisplay.textContent = `LIVES: ${gameState.lives}`;
            // Update timer display
            timerDisplay.textContent = `TIMER: ${gameState.currentTime.toFixed(2)}s`; 
        }

        function checkCollisions() {
            const t = gameState.turtle;
            // Use the grid-aligned Y for checking the lane
            const currentRow = Math.round(t.y / GRID_SIZE); 
            const currentLane = gameState.lanes[currentRow];

            // If turtle is not perfectly on a row, skip collision check (it's in the middle of a hop)
            if (t.y % GRID_SIZE !== 0) return;

            if (!currentLane) return; 

            // 1. Road Hazards
            if (currentLane.type === 'road') {
                let hitCar = false;
                for (const entity of currentLane.entities) {
                    if (entity.isColliding(t)) {
                        hitCar = true;
                        break;
                    }
                }
                if (hitCar) return resetTurtle('hit');
            }

            // 2. River Hazards
            if (currentLane.type === 'river') {
                let onPlatform = false;
                t.isCarried = false;
                t.carriedBy = null;

                for (const entity of currentLane.entities) {
                    if (entity.isColliding(t)) {
                        onPlatform = true;
                        t.isCarried = true;
                        t.carriedBy = entity;
                        break;
                    }
                }
                
                // If not on a platform, the turtle is in the water!
                if (!onPlatform) {
                    return resetTurtle('drowned');
                }
            }
            
            // 3. Home Zone (Row 0)
            if (currentRow === 0) {
                 levelUp();
            }
        }

        function carryTurtle() {
            const t = gameState.turtle;
            if (t.isCarried && t.carriedBy) {
                const carrier = t.carriedBy;
                
                // Entity speed is constant now, no multiplier needed
                const moveAmount = carrier.speed * gameState.deltaTime / 1000;
                
                t.x += moveAmount;
                t.targetX += moveAmount;

                // Check if carried off-screen
                if (t.x < -GRID_SIZE || t.x > CANVAS_WIDTH) { 
                    return resetTurtle('carried-off');
                }
            }
        }

        function resetTurtle(reason) {
            gameState.lives--;
            updateHUD();
            
            if (gameState.lives <= 0) {
                gameOver();
            } else {
                // Reset time limit on death
                gameState.currentTime = gameState.timeLimit; 
                gameState.turtle.reset();
                
                // Brief pause on death
                gameState.isPaused = true;
                
                let message = "";
                if (reason === 'hit') message = "CRASH! Watch out for the traffic.";
                if (reason === 'drowned') message = "SPLASH! You fell in the water.";
                if (reason === 'carried-off') message = "OFF SCREEN! Stay on the logs.";
                if (reason === 'timeout') message = "TIME OUT! You took too long to cross."; 
                
                messageTitle.textContent = "LOST A LIFE";
                messageText.textContent = `${message} You have ${gameState.lives} lives remaining.`;
                restartButton.textContent = "CONTINUE";
                messageOverlay.style.display = 'flex';
                
                // Allow the player to start again via the button
                // setTimeout(() => { gameState.isPaused = false; }, 500); // Removed auto-resume
            }
        }
        
        function levelUp() {
            gameState.level++;
            // Award score and apply level bonus
            gameState.score += 100 * gameState.level;
            
            // Set new time limit and reset current time
            gameState.timeLimit = getLaneTimeLimit();
            gameState.currentTime = gameState.timeLimit;
            
            // Re-initialize all non-safe lanes to re-randomize entity positions
            gameState.lanes.forEach(lane => {
                if(lane.type !== 'safe') {
                    lane.initEntities(); 
                }
            });
            
            gameState.turtle.reset();
            gameState.isPaused = true;
            
            messageTitle.textContent = "LEVEL UP!";
            messageText.textContent = `You reached safety! The new time limit is ${gameState.timeLimit.toFixed(0)} seconds.`;
            restartButton.textContent = "CONTINUE";
            messageOverlay.style.display = 'flex';
        }

        function gameOver() {
            gameState.isPaused = true;
            // Stop the animation loop
            if (gameState.animationFrameId) {
                cancelAnimationFrame(gameState.animationFrameId);
                gameState.animationFrameId = null;
            }

            messageTitle.textContent = "GAME OVER";
            messageText.textContent = `You ran out of lives! Final Score: ${gameState.score}`;
            restartButton.textContent = "RESTART GAME";
            messageOverlay.style.display = 'flex';
        }

        // --- Game Loop ---

        function animate(timestamp) {
            
            gameState.deltaTime = timestamp - gameState.lastUpdateTime;
            gameState.lastUpdateTime = timestamp;
            
            if (!gameState.isPaused) {
                // Decrement timer
                gameState.currentTime -= gameState.deltaTime / 1000;
                
                if (gameState.currentTime <= 0) {
                    // Time's up!
                    gameState.currentTime = 0;
                    // Reset turtle and deduct life due to timeout
                    resetTurtle('timeout'); 
                }
            }

            // 1. Clear Canvas
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // 2. Update and Draw Lanes/Entities
            gameState.lanes.forEach(lane => {
                lane.update(gameState.deltaTime);
                lane.draw();
            });

            // 3. Check for platform movement
            carryTurtle();
            
            // 4. Draw Player
            gameState.turtle.draw();

            // 5. Check Collisions (only if not paused)
            if (!gameState.isPaused) {
                checkCollisions();
            }
            
            // 6. Update HUD
            updateHUD(); 

            // 7. Request next frame
            gameState.animationFrameId = requestAnimationFrame(animate);
        }

        // --- Event Handlers ---

        function handleKey(event) {
            let dx = 0, dy = 0;
            const step = GRID_SIZE;

            switch (event.key.toLowerCase()) {
                case 'w':
                case 'arrowup':
                    dy = -step;
                    event.preventDefault(); 
                    break;
                case 's':
                case 'arrowdown':
                    dy = step;
                    event.preventDefault();
                    break;
                case 'a':
                case 'arrowleft':
                    dx = -step;
                    event.preventDefault();
                    break;
                case 'd':
                case 'arrowright':
                    dx = step;
                    event.preventDefault();
                    break;
            }
            
            if (dx !== 0 || dy !== 0) {
                gameState.turtle.move(dx, dy);
            }
        }
        
        function setupMobileControls() {
            const controls = [
                { id: 'up-btn', dx: 0, dy: -GRID_SIZE },
                { id: 'down-btn', dx: 0, dy: GRID_SIZE },
                { id: 'left-btn', dx: -GRID_SIZE, dy: 0 },
                { id: 'right-btn', dx: GRID_SIZE, dy: 0 }
            ];

            controls.forEach(control => {
                const btn = document.getElementById(control.id);
                btn.addEventListener('click', () => {
                    gameState.turtle.move(control.dx, control.dy);
                });
            });
        }


        // --- Initialization ---
        window.addEventListener('load', () => {
            document.addEventListener('keydown', handleKey);
            
            // Handle Start/Continue button (for overlay)
            restartButton.addEventListener('click', () => {
                // If it's the very first start or after a game over, initialize completely
                if (gameState.isPaused && gameState.lives <= 0 || gameState.score === 0 && gameState.level === 1) {
                    initGame();
                } else { // Otherwise, just resume from a level up or death
                    gameState.isPaused = false; 
                }
                messageOverlay.style.display = 'none'; // Hide overlay
            });
            
            // Handle the new dedicated Reset button (in HUD)
            resetButton.addEventListener('click', () => {
                initGame();
                gameState.isPaused = false; 
            });
            
            setupMobileControls();
            
            // Initial instructions screen
            messageTitle.textContent = "TURTLE HOPPER: TIME CHALLENGE";
            messageText.textContent = "Help the turtle hop across the road and river to reach safety. You now have a time limit that shrinks with every level! Use WASD/Arrows to move.";
            restartButton.textContent = "START HOPPING";
            messageOverlay.style.display = 'flex';
        });

    </script>
</body>
</html>
