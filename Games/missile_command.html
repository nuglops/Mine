<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Missile Command</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Retro Vector Aesthetic */
        :root {
            --color-sky: #0d0d0d;
            --color-ground: #333333;
            --color-city: #00ff7f; /* Neon Green */
            --color-base: #00bfff; /* Neon Blue */
            --color-enemy: #ff0000; /* Red */
            --color-player: #ffff00; /* Yellow */
            --color-explosion: #ff9900; /* Orange */
            --color-text: #ffffff;
            --font-main: 'Monospace', 'Courier New', sans-serif;
        }

        body {
            background-color: var(--color-sky);
            font-family: var(--font-main);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            margin: 0;
            padding: 10px;
        }

        #game-area {
            max-width: 800px; 
            width: 95vw; 
            aspect-ratio: 5 / 3; /* Wide screen aspect ratio */
            border: 4px solid var(--color-text);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.4);
            border-radius: 4px;
            position: relative;
            background-color: var(--color-sky);
            cursor: crosshair; /* Crosshair cursor for targeting */
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #hud {
            width: 100%;
            max-width: 800px;
            color: var(--color-text);
            padding: 10px 0;
            display: flex;
            justify-content: space-between;
            font-size: 1.2rem;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }
        
        #message-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            color: var(--color-text);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            text-align: center;
            border-radius: 4px;
        }

        .action-button {
            background-color: var(--color-base);
            color: var(--color-sky);
            padding: 12px 25px;
            border-radius: 6px;
            font-weight: 700;
            cursor: pointer;
            margin-top: 25px;
            transition: all 0.2s;
            border: 2px solid var(--color-base);
            box-shadow: 0 0 15px var(--color-base);
        }
        .action-button:hover { 
            background-color: #ffffff;
            color: var(--color-sky);
            box-shadow: 0 0 20px #ffffff;
        }

        #controls-info {
            margin-top: 15px;
            color: #999;
            font-size: 0.8rem;
        }
    </style>
</head>
<body>

    <div id="hud">
        <span>SCORE: <span id="score">0</span></span>
        <span>ROUND: <span id="current-round">0</span></span>
        <span>CITIES SAFE: <span id="cities-safe">4</span></span>
    </div>

    <div id="game-area">
        <canvas id="missileCommandCanvas"></canvas>

        <div id="message-overlay" class="message-overlay">
            <h2 id="message-title" class="text-4xl mb-4 text-red-500">MISSILE COMMAND</h2>
            <p id="message-text" class="mb-6 text-xl text-yellow-300">
                **Protect your cities!**<br>
                Click anywhere in the sky to launch an interceptor missile.<br>
                The interceptor explodes at the click point, destroying enemy missiles in the blast radius.<br><br>
                Survive 20 enemy missiles to complete a round.
            </p>
            <button class="action-button" id="start-button">START DEFENSE</button>
        </div>
    </div>
    
    <div id="controls-info">
        Control: Mouse Click (Launch Interceptor)
    </div>

    <script>
        // --- Game Configuration & Constants (Normalized Units: 0-1000 W x 0-600 H) ---
        const N_WIDTH = 1000;
        const N_HEIGHT = 600;

        const CITY_WIDTH = 80;
        const CITY_HEIGHT = 40;
        const GROUND_HEIGHT = 30;
        const CITY_Y = N_HEIGHT - GROUND_HEIGHT;

        const BASE_LAUNCH_X = N_WIDTH / 2;
        const BASE_LAUNCH_Y = N_HEIGHT - GROUND_HEIGHT - 10;
        const BASE_RADIUS = 10;

        const ENEMY_MISSILE_BASE_SPEED = 1.0; // Base speed for Round 1
        const ENEMY_SPEED_INCREASE_PER_ROUND = 0.005; // 0.5% increase per round (multiplier)
        const ROUND_MISSILE_COUNT = 20; // Fixed number of missiles per round

        const PLAYER_MISSILE_SPEED = 8.0;
        const EXPLOSION_MAX_RADIUS = 70;
        const EXPLOSION_LIFETIME = 40; // frames
        const MAX_SPAWN_RATE = 1000; // ms (minimum)
        const INITIAL_SPAWN_RATE = 2500; // ms (start rate)
        
        // Central Base Definition (Needed globally for active status check)
        const BASE = {
            active: true,
            x: BASE_LAUNCH_X,
            y: BASE_LAUNCH_Y
        };

        // --- Game State Variables ---
        let canvas, ctx;
        let score = 0;
        let isPlaying = false;
        let gameOver = false; 
        
        let currentRound = 0;
        let missilesToSpawn = 0;
        let missilesSpawned = 0;
        let difficultyMultiplier = 1;

        let lastSpawnTime = 0;
        let animationFrameId;

        // CITIES: x is center point
        let cities = [
            { id: 0, x: 150, y: CITY_Y, active: true, width: CITY_WIDTH, height: CITY_HEIGHT },
            { id: 1, x: 350, y: CITY_Y, active: true, width: CITY_WIDTH, height: CITY_HEIGHT },
            { id: 2, x: 650, y: CITY_Y, active: true, width: CITY_WIDTH, height: CITY_HEIGHT },
            { id: 3, x: 850, y: CITY_Y, active: true, width: CITY_WIDTH, height: CITY_HEIGHT }
        ];

        let enemyMissiles = [];
        let playerMissiles = [];
        let explosions = [];

        // --- Utility Functions ---

        const getColor = (name) => getComputedStyle(document.documentElement).getPropertyValue(name).trim();

        function scaleX(n_x) { return n_x * canvas.width / N_WIDTH; }
        function scaleY(n_y) { return n_y * canvas.height / N_HEIGHT; }
        function scaleLength(n_l) { return n_l * canvas.width / N_WIDTH; }

        function normalizeX(s_x) { return s_x * N_WIDTH / canvas.width; }
        function normalizeY(s_y) { return s_y * N_HEIGHT / canvas.height; }

        function distance(x1, y1, x2, y2) {
            return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        }
        
        // --- Core Game Functions ---

        function setupCanvas() {
            canvas = document.getElementById('missileCommandCanvas');
            ctx = canvas.getContext('2d');
            
            const rect = canvas.parentNode.getBoundingClientRect();
            // Set canvas size based on its container's aspect ratio
            canvas.width = rect.width;
            canvas.height = rect.height;
        }

        function resetGame() {
            score = 0;
            difficultyMultiplier = 1;
            enemyMissiles = [];
            playerMissiles = [];
            explosions = [];
            lastSpawnTime = 0;
            gameOver = false; 
            currentRound = 0;
            missilesToSpawn = 0;
            missilesSpawned = 0;

            // Reset all cities and base to active
            cities.forEach(city => city.active = true);
            BASE.active = true; 
            
            updateHUD();
        }

        function startGame() {
            resetGame();
            isPlaying = true;
            // Start the first round
            startRound(1); 
            if (!animationFrameId) {
                gameLoop();
            }
        }

        function startRound(round) {
            currentRound = round;
            missilesToSpawn = ROUND_MISSILE_COUNT;
            missilesSpawned = 0;
            enemyMissiles = []; // Clear any missiles left from a previous failed round
            playerMissiles = [];
            explosions = [];
            
            // Calculate new difficulty multiplier: 1.0 + 0.5% * (Round - 1)
            difficultyMultiplier = ENEMY_MISSILE_BASE_SPEED + ENEMY_SPEED_INCREASE_PER_ROUND * (round - 1);
            
            // Show round transition screen
            showOverlay(`ROUND ${currentRound}`, 
                `Enemy speed multiplier: ${difficultyMultiplier.toFixed(3)}x. Get ready!`);
            
            // Small delay before actual play starts
            setTimeout(() => {
                document.getElementById('message-overlay').style.display = 'none';
                lastSpawnTime = performance.now(); // Reset spawn timer
                isPlaying = true;
            }, 1500); 

            updateHUD();
        }
        
        // --- Game Entities Logic ---

        function spawnEnemyMissile() {
            if (missilesSpawned >= missilesToSpawn) {
                return; // Stop spawning for this round
            }

            // Target a random active city or the base (if active)
            const targets = cities.filter(c => c.active);
            
            // Add central base as a potential target
            if (targets.length > 0) { 
                // Only target the base if there are cities left (just to spice things up a bit)
                targets.push({ x: BASE_LAUNCH_X, y: BASE_LAUNCH_Y, isBase: true, active: BASE.active });
            } 
            
            if (targets.length === 0) return; // No targets left

            const target = targets[Math.floor(Math.random() * targets.length)];

            // Start from a random point at the top of the screen (Y=0)
            const startX = Math.random() * N_WIDTH;
            const startY = 0;

            const dx = target.x - startX;
            const dy = target.y - startY;
            const dist = distance(startX, startY, target.x, target.y);
            
            // Normalize direction vector and apply speed, scaled by difficulty multiplier
            const speed = ENEMY_MISSILE_BASE_SPEED * difficultyMultiplier;
            const vx = (dx / dist) * speed;
            const vy = (dy / dist) * speed;

            enemyMissiles.push({
                x: startX,
                y: startY,
                vx: vx,
                vy: vy,
                target: target,
                dist: dist,
                color: getColor('--color-enemy')
            });

            missilesSpawned++;
        }

        function launchPlayerMissile(targetX, targetY) {
            if (!isPlaying || gameOver || !BASE.active) return;
            
            const startX = BASE_LAUNCH_X;
            const startY = BASE_LAUNCH_Y;

            // Calculate movement vectors
            const dx = targetX - startX;
            const dy = targetY - startY;
            const dist = distance(startX, startY, targetX, targetY);

            // Normalize direction vector and apply speed
            const vx = (dx / dist) * PLAYER_MISSILE_SPEED;
            const vy = (dy / dist) * PLAYER_MISSILE_SPEED;

            playerMissiles.push({
                startX: startX,
                startY: startY,
                x: startX,
                y: startY,
                vx: vx,
                vy: vy,
                targetX: targetX,
                targetY: targetY,
                dist: dist
            });
        }

        function createExplosion(x, y) {
            explosions.push({
                x: x,
                y: y,
                radius: 0,
                maxRadius: EXPLOSION_MAX_RADIUS,
                lifetime: EXPLOSION_LIFETIME,
                age: 0
            });
        }

        // --- Update Functions ---

        function updateEnemyMissiles() {
            for (let i = enemyMissiles.length - 1; i >= 0; i--) {
                const missile = enemyMissiles[i];
                
                // Move missile
                missile.x += missile.vx;
                missile.y += missile.vy;
                
                // Check if target is reached (check if we passed the target Y)
                if (missile.y >= missile.target.y - 5) {
                    
                    // Detonate on impact
                    createExplosion(missile.x, missile.y);

                    // Check if a city or base was hit
                    if (!missile.target.isBase && missile.target.active) {
                        // Impacted a city
                        missile.target.active = false;
                        score -= 50; // Penalty for lost city
                    }
                    
                    if (missile.target.isBase && BASE.active) {
                        // Impacted the base
                        BASE.active = false; 
                    }

                    // Remove missile
                    enemyMissiles.splice(i, 1);
                    checkGameOver();
                    checkRoundEnd(); // Check if round is over
                    updateHUD();
                }
            }
        }

        function updatePlayerMissiles() {
            for (let i = playerMissiles.length - 1; i >= 0; i--) {
                const missile = playerMissiles[i];

                // Move missile
                missile.x += missile.vx;
                missile.y += missile.vy;

                // Check if target is reached (normalized distance check is more robust)
                const distToTarget = distance(missile.x, missile.y, missile.targetX, missile.targetY);
                
                if (distToTarget < PLAYER_MISSILE_SPEED) {
                    // Detonate
                    createExplosion(missile.targetX, missile.targetY);
                    
                    // Remove missile
                    playerMissiles.splice(i, 1);
                }
            }
        }
        
        function updateExplosions() {
            for (let i = explosions.length - 1; i >= 0; i--) {
                const exp = explosions[i];
                exp.age++;
                
                // Radius expands for first half of life, then shrinks
                if (exp.age < exp.lifetime / 2) {
                    exp.radius = (exp.age / (exp.lifetime / 2)) * exp.maxRadius;
                } else {
                    exp.radius = ((exp.lifetime - exp.age) / (exp.lifetime / 2)) * exp.maxRadius;
                }

                // Check for enemy missile hits
                for (let j = enemyMissiles.length - 1; j >= 0; j--) {
                    const missile = enemyMissiles[j];
                    const distToCenter = distance(missile.x, missile.y, exp.x, exp.y);
                    
                    if (distToCenter < exp.radius) {
                        // Hit! Remove missile and score points
                        enemyMissiles.splice(j, 1);
                        score += 10;
                        updateHUD();
                        checkRoundEnd(); // Check for round end after a successful interception
                    }
                }
                
                // Remove explosion when life is up
                if (exp.age >= exp.lifetime) {
                    explosions.splice(i, 1);
                }
            }
        }

        function updateSpawning(currentTime) {
            // Only spawn if the round is not over and we haven't reached the missile cap
            if (missilesSpawned < missilesToSpawn) {
                const targetSpawnRate = INITIAL_SPAWN_RATE / difficultyMultiplier;
                const currentSpawnRate = Math.max(MAX_SPAWN_RATE, targetSpawnRate);
                
                if (currentTime - lastSpawnTime > currentSpawnRate) {
                    spawnEnemyMissile();
                    lastSpawnTime = currentTime;
                }
            }
        }

        // --- Drawing Functions (No changes needed here for logic) ---
        
        function drawCities() {
            ctx.fillStyle = getColor('--color-city');
            cities.forEach(city => {
                if (city.active) {
                    const scaledX = scaleX(city.x - city.width / 2);
                    const scaledY = scaleY(city.y - city.height);
                    const scaledW = scaleLength(city.width);
                    const scaledH = scaleY(city.height);
                    
                    ctx.shadowColor = getColor('--color-city');
                    ctx.shadowBlur = 10;
                    ctx.fillRect(scaledX, scaledY, scaledW, scaledH);
                    ctx.shadowBlur = 0;
                } else {
                    // Draw destroyed city remains
                    ctx.fillStyle = getColor('--color-ground');
                    const scaledX = scaleX(city.x - city.width / 2);
                    const scaledY = scaleY(city.y - 10);
                    const scaledW = scaleLength(city.width);
                    ctx.fillRect(scaledX, scaledY, scaledW, 10);
                }
            });
        }

        function drawBase() {
            const scaledX = scaleX(BASE_LAUNCH_X);
            const scaledY = scaleY(BASE_LAUNCH_Y);
            const scaledR = scaleLength(BASE_RADIUS);
            
            ctx.fillStyle = BASE.active ? getColor('--color-base') : getColor('--color-ground');
            ctx.shadowColor = BASE.active ? getColor('--color-base') : 'transparent';
            ctx.shadowBlur = BASE.active ? 10 : 0;
            
            ctx.beginPath();
            ctx.arc(scaledX, scaledY, scaledR, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Draw launch cone
            ctx.fillStyle = BASE.active ? 'rgba(0, 191, 255, 0.3)' : 'transparent';
            ctx.beginPath();
            ctx.moveTo(scaledX, scaledY);
            ctx.lineTo(scaleX(BASE_LAUNCH_X - 20), scaleY(N_HEIGHT));
            ctx.lineTo(scaleX(BASE_LAUNCH_X + 20), scaleY(N_HEIGHT));
            ctx.closePath();
            ctx.fill();
        }

        function drawEnemyMissiles() {
            ctx.strokeStyle = getColor('--color-enemy');
            ctx.lineWidth = 2;
            ctx.shadowColor = getColor('--color-enemy');
            ctx.shadowBlur = 5;

            enemyMissiles.forEach(missile => {
                const scaledX = scaleX(missile.x);
                const scaledY = scaleY(missile.y);
                const scaledVX = scaleLength(missile.vx);
                const scaledVY = scaleY(missile.vy);
                
                // Draw missile as a line (tail is opposite to velocity)
                ctx.beginPath();
                ctx.moveTo(scaledX, scaledY);
                // Draw line backward based on velocity vector for a tail effect
                ctx.lineTo(scaledX - scaledVX * 10, scaledY - scaledVY * 10); 
                ctx.stroke();
            });
            ctx.shadowBlur = 0;
        }

        function drawPlayerMissiles() {
            ctx.strokeStyle = getColor('--color-player');
            ctx.lineWidth = 3;
            ctx.shadowColor = getColor('--color-player');
            ctx.shadowBlur = 5;

            playerMissiles.forEach(missile => {
                const scaledX = scaleX(missile.x);
                const scaledY = scaleY(missile.y);
                const scaledStartX = scaleX(missile.startX);
                const scaledStartY = scaleY(missile.startY);

                // Draw missile as a line from base to current position
                ctx.beginPath();
                ctx.moveTo(scaledStartX, scaledStartY);
                ctx.lineTo(scaledX, scaledY);
                ctx.stroke();
            });
            ctx.shadowBlur = 0;
        }

        function drawExplosions() {
            explosions.forEach(exp => {
                const scaledX = scaleX(exp.x);
                const scaledY = scaleY(exp.y);
                const scaledR = scaleLength(exp.radius);
                
                // Fade color based on age
                const opacity = 1 - (exp.age / exp.lifetime);
                
                ctx.strokeStyle = `rgba(255, 153, 0, ${opacity})`; // Orange
                ctx.lineWidth = 4;
                ctx.shadowColor = `rgba(255, 255, 0, ${opacity})`; // Yellow glow
                ctx.shadowBlur = 15;
                
                // Draw expanding/contracting circle
                ctx.beginPath();
                ctx.arc(scaledX, scaledY, scaledR, 0, Math.PI * 2);
                ctx.stroke();
            });
            ctx.shadowBlur = 0;
        }

        function drawGround() {
            // Draw solid ground layer
            ctx.fillStyle = getColor('--color-ground');
            ctx.fillRect(0, scaleY(N_HEIGHT - GROUND_HEIGHT), canvas.width, scaleY(GROUND_HEIGHT));
        }

        function draw() {
            // Clear canvas
            ctx.fillStyle = getColor('--color-sky');
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawGround();
            drawCities();
            drawBase();
            drawEnemyMissiles();
            drawPlayerMissiles();
            drawExplosions();
        }

        // --- Game Flow Control ---
        
        function updateHUD() {
            document.getElementById('score').textContent = score;
            document.getElementById('current-round').textContent = currentRound;
            const safeCities = cities.filter(c => c.active).length;
            document.getElementById('cities-safe').textContent = safeCities;
        }

        function checkRoundEnd() {
            // Check if all 20 missiles have been spawned AND all enemy missiles are gone
            if (missilesSpawned >= missilesToSpawn && enemyMissiles.length === 0) {
                isPlaying = false; // Pause game for transition

                const safeCities = cities.filter(c => c.active).length;
                const bonus = safeCities * 100;
                score += bonus;
                
                showOverlay(`ROUND ${currentRound} COMPLETE!`, 
                    `City Survival Bonus: +${bonus} points (Score: ${score}). Get ready for the next wave!`);
                
                const startButton = document.getElementById('start-button');
                startButton.textContent = `START ROUND ${currentRound + 1}`;
                startButton.onclick = () => {
                    startRound(currentRound + 1);
                };

                updateHUD();
            }
        }

        function checkGameOver() {
            const safeCities = cities.filter(c => c.active).length;
            
            if (safeCities === 0) {
                gameOver = true;
                isPlaying = false;
                showOverlay('ALL CITIES DESTROYED', `Final Score: ${score}. Better luck next time!`);
                
                const startButton = document.getElementById('start-button');
                startButton.textContent = 'PLAY AGAIN';
                startButton.onclick = startGame;
            }
        }

        function showOverlay(title, text) {
            document.getElementById('message-title').textContent = title;
            document.getElementById('message-text').innerHTML = text; 
            document.getElementById('message-overlay').style.display = 'flex';
        }

        function gameLoop(timestamp) {
            if (isPlaying) {
                updateSpawning(timestamp);
                updateEnemyMissiles();
                updatePlayerMissiles();
                updateExplosions();
                draw();
            }
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // --- Event Handlers ---

        function handleClick(e) {
            if (!isPlaying || gameOver || !BASE.active) return;
            
            // Get click coordinates relative to canvas
            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;
            
            // Convert to normalized coordinates
            const n_clickX = normalizeX(clickX);
            const n_clickY = normalizeY(clickY);
            
            // Prevent launching below the ground
            if (n_clickY < CITY_Y) {
                launchPlayerMissile(n_clickX, n_clickY);
            }
        }

        // --- Initial Load ---

        window.addEventListener('load', () => {
            setupCanvas();
            
            // Re-setup the canvas on resize to keep it responsive
            window.addEventListener('resize', setupCanvas);
            
            document.getElementById('missileCommandCanvas').addEventListener('click', handleClick);
            
            // Ensure the start button always calls startGame initially
            document.getElementById('start-button').addEventListener('click', startGame);
            
            draw(); // Draw initial state
        });
    </script>
</body>
</html>
